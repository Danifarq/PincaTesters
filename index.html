<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sistemas de Gesti√≥n de Calidad</title>
    <link rel="stylesheet" href="css/styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&family=Playfair+Display:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>

    <header class="header">
        <div class="logo">Los Pinca Testers V2</div>
        <nav class="nav">
            <ul class="nav-list">
                <li><a href="#inicio">INICIO</a></li>
                <li><a href="#calidad">CALIDAD DEL SOFTWARE</a></li>
                <li><a href="#procesos">PROCESOS DE DESARROLLO</a></li>
                <li><a href="#recursos">RECURSOS</a></li>
                <li><a href="#acerca-de">ACERCA DE</a></li>
            </ul>
        </nav>
    </header>

    <main class="main-content">
        <section id="inicio" class="section hero-section">
            <h1>Sistemas de Gesti√≥n de Calidad</h1>
            <p>Aqu√≠ aprender√°s los conceptos clave para implementar sistemas de calidad en proyectos de software, conocer√°s las principales herramientas utilizadas por profesionales y descubrir√°s c√≥mo los modelos tradicionales y modernos ayudan a garantizar la excelencia</p>
        </section>
 <!--INICIO SEGUNDA PANTALLA-->
        <section id="calidad" class="section">
            <h2 class="section-title"> ¬øQu√© es la Gesti√≥n de la Calidad del Software?</h2>
            <p>La Gesti√≥n de la Calidad del Software (GCS) es el proceso de asegurar que un producto de software cumpla con los est√°ndares de calidad definidos. Esto implica planificar, monitorear y mejorar la forma en que se desarrolla el software. Su objetivo principal es prevenir errores y garantizar un producto final confiable, eficiente y seguro.</p>
          <div class="card-container">
            <div class="card full-width">
    <i class="fas fa-vial icon"></i>
                    <h3>üìò Fundamentos de Calidad:</h3>
                   
                    <p>La calidad del software se define a trav√©s de varios atributos que determinan su valor y comportamiento. Los conceptos fundamentales son:</p>
            <h4>Calidad del Software</h4>
                    <ul>
                <p>Un software de calidad debe ser:</p>
                <li>Confiable: funcionar sin fallas en diferentes condiciones.</li>
                <li>Eficiente: utilizar de manera √≥ptima los recursos (tiempo de respuesta, memoria, etc.).</li>
                <li>Usable: f√°cil de aprender y utilizar por el usuario final.</li>
                <li>Mantenible: sencillo de modificar, corregir y actualizar.</li>
                <li>Port√°til: capaz de funcionar en distintos entornos y plataformas.</li>
            </ul>
            <h4>M√©tricas de Calidad</h4>
            <p>Las m√©tricas de calidad son indicadores que permiten medir objetivamente caracter√≠sticas del software. Algunas de las m√°s utilizadas son:</p>
            <ul>
                <li>Correcci√≥n: n√∫mero de defectos encontrados durante pruebas o uso.</li>
                <li>Fiabilidad: tiempo medio entre fallos (MTBF).</li>
                <li>Usabilidad: tiempo que tarda un usuario en aprender a usar el sistema.</li>
                <li>Eficiencia: tiempo de respuesta o consumo de recursos.</li>
                <li>Mantenibilidad: facilidad y costo de aplicar cambios.</li>
            </ul>
            <p>Estas m√©tricas ayudan a evaluar la calidad del producto y a tomar decisiones para mejorar su desarrollo y mantenimiento.</p>
            <h4>Est√°ndares Internacionales</h4>
            <p>üìëISO/IEC 9126</p>
            <p>Fue uno de los primeros est√°ndares de calidad de software. Define un modelo basado en 6 caracter√≠sticas principales:</p>
            <ol>
                <li>Funcionalidad</li>
                <li>Fiabilidad</li>
                <li>Usabilidad</li>
                <li>Eficiencia</li>
                <li>Mantenibilidad</li>
                <li>Portabilidad</li>
            </ol>
            <p>Cada una se descompone en subcaracter√≠sticas que permiten una evaluaci√≥n m√°s detallada</p>
            <h4>üìëISO/IEC 25000 (SQuaRE)</h4>
            <p>Es la evoluci√≥n de la ISO 9126. Propone un marco m√°s completo para la gesti√≥n de la calidad de software:</p>
<ul>
    <li>Define requisitos de calidad.</li>
    <li>Establece m√©tricas para evaluarla.</li>
    <li>Incluye gu√≠as para la medici√≥n y validaci√≥n.</li>
</ul>
<p>Su objetivo es facilitar que las organizaciones desarrollen productos que cumplan con est√°ndares reconocidos internacionalmente.</p>
        </div>
                            <div class="card full-width">
    <i class="fas fa-vial icon"></i>
                    <h3>Herramientas de Calidad:</h3>
                    <p>Para gestionar eficazmente la calidad, se utilizan diversas herramientas especializadas.</p>
                <h4>‚úÖHerramientas de Gesti√≥n de Pruebas</h4>
                <p>Ayudan a organizar todo el proceso de testing:</p>
                <ul>
                    <li>Creaci√≥n de planes de prueba.</li>
                    <li>Dise√±o de casos de prueba.</li>
                    <li>Asignaci√≥n de pruebas a testers.</li>
                    <li>Ejecuci√≥n de pruebas.</li>
                    <li>Generaci√≥n de informes de resultados.</li>
                      </ul>
                    <p>Ejemplos:
                        <a href="https://www.gurock.com/testrail/">TestRail</a>
                        <a href="https://www.getxray.app/">Xray</a>
                        <a href="https://smartbear.com/test-management/zephyr/">Zephyr</a>
                        (estos dos √∫ltimos se integran con Jira).</p>
              
                <h4>‚úÖHerramientas de Seguimiento de Defectos (Bug Tracking)</h4>
                <p>Permiten registrar y dar seguimiento a errores encontrados durante pruebas o en producci√≥n. Cada bug se gestiona como un ticket, con informaci√≥n sobre:</p>
                <ul>
                    <li>Descripci√≥n del error.</li>
                    <li>Prioridad y criticidad.</li>
                    <li>Estado (abierto, en progreso, resuelto).</li>
                    <li>Responsable asignado.</li>
                </ul>
                    <p>Ejemplos: 
                        <a href="https://www.atlassian.com/software/jira">Jira</a>
                        <a href="https://www.bugzilla.org/">Bugzilla</a>
                        <a href="https://www.redmine.org/">Redmine</a>
                        </p>
                <h4>‚úÖHerramientas de An√°lisis de Calidad de C√≥digo</h4>
                <p> Analizan autom√°ticamente el c√≥digo fuente para detectar:</p>
                <ul>
                    <li>Errores potenciales.</li>
                    <li>Vulnerabilidades de seguridad.</li>
                    <li>C√≥digo duplicado o redundante.</li>
                    <li>Malas pr√°cticas de programaci√≥n.</li>
                     </ul>
                    <p>Ejemplos: 
                        <a href="https://www.sonarsource.com/sonarqube/">SonarQube</a>
                        <a href="https://www.veracode.com/">Veracode</a>
                        <a href="https://checkstyle.sourceforge.io/">Jira</a>
                        Estas herramientas fomentan la mantenibilidad y robustez del software.
                        </p>
               
                </div>
             <div class="card full-width">
    <i class="fas fa-vial icon"></i>
                    <h3>T√©cnicas de Aseguramiento de la Calidad:</h3>
                    <p>El QA se apoya en diversas t√©cnicas, siendo las pruebas de software la m√°s fundamental.</p>
                       <p>Pruebas de Software (Software Testing): Consiste en ejecutar el software para verificar que funciona como se espera y para encontrar defectos. Se organiza en niveles y tipos.</p>
                            <p>Niveles de Pruebas: Los niveles siguen un orden l√≥gico, desde lo m√°s peque√±o hasta el sistema completo.</p>
               <ol>
                <li>Pruebas Unitarias: Se prueba el componente m√°s peque√±o del c√≥digo (una funci√≥n, un m√©todo) de forma aislada. Son r√°pidas y las suelen escribir los propios desarrolladores.</li>
                <li>Pruebas de Integraci√≥n: Se combinan dos o m√°s unidades ya probadas y se verifica que funcionan juntas correctamente (por ejemplo, que el m√≥dulo de login se comunique bien con la base de datos de usuarios).</li>
                <li>Pruebas de Sistema: Se prueba la aplicaci√≥n completa y totalmente integrada para asegurar que cumple con todos los requisitos funcionales y no funcionales</li>
                <li>Pruebas de Aceptaci√≥n (UAT): Realizadas por el cliente o los usuarios finales para validar que el software resuelve sus necesidades y es "aceptado" para su lanzamiento.</li>
                </ol>
                <p>Tipos y T√©cnicas de Pruebas</p>
                <p>Se clasifican seg√∫n lo que se quiere probar y c√≥mo se dise√±a la prueba.</p>
                <ul>
                    <li>Pruebas Funcionales: Verifican qu√© hace el sistema. Se basan en los requisitos.</li>
                    <p>Ejemplo: Probar que un formulario de registro guarda la informaci√≥n del usuario correctamente</p>
                    <ul>
                        <li>Pruebas No Funcionales: Verifican c√≥mo opera el sistema.</li>
                            <ul>
                                 <li>Pruebas de Rendimiento: ¬øEs r√°pido? ¬øSoporta muchos usuarios a la vez?</li>
                                 <li>Pruebas de Usabilidad: ¬øEs intuitivo y f√°cil de usar?</li>
                                <li>Pruebas de Seguridad: ¬øEs vulnerable a ataques?</li>
                             </ul>
                    </ul>
                    <li>T√©cnicas de Dise√±o de Pruebas:</li>
                        <ul>
                            <li>Caja Negra (Black-Box Testing): Se realizan las pruebas sin conocer el c√≥digo interno. Solo se validan las entradas y salidas. Es como usar una app sin saber c√≥mo fue programada.</li>
                            <li>Caja Blanca (White-Box Testing): Se dise√±an las pruebas conociendo la estructura del c√≥digo, para asegurar que se recorren todos los caminos l√≥gicos posibles.</li>
                            <li>Caja Gris (Gray-Box Testing): Una mezcla de ambas, donde el probador tiene un conocimiento parcial del sistema interno.</li>
                        </ul>
                </ul>
                </div>
               
            </div>
        </section>
     <!--FIN SEGUNDA PANTALLA-->
      <!--INICIO TERCERA PANTALLA-->
        <section id="procesos" class="section">
            <h2 class="section-title">Procesos de Desarrollo de Software</h2>
            <p>Un proceso de desarrollo de software es un marco de trabajo estructurado que se utiliza para planificar, crear, probar y desplegar software de alta calidad. Define qui√©n hace qu√©, cu√°ndo y c√≥mo.</p>
            <div class="slider-container">
                <div class="card slide">
                    <h3>Ciclo de Vida del Desarrollo de Software (SDLC)</h3>
                    <p>El Ciclo de Vida del Desarrollo de Software (SDLC - Software Development Life Cycle) es el proceso l√≥gico que siguen los equipos de desarrollo para construir y mantener un software. Cada etapa produce una salida que es la entrada para la siguiente.</p>
                <p>Las etapas t√≠picas son:</p>
                <ol>
                    <li>Planificaci√≥n y An√°lisis de Requisitos üìù: Es la fase fundamental. Se recopilan los requisitos de los clientes y stakeholders. Se define el alcance del proyecto, los objetivos, el presupuesto y los recursos necesarios. Se busca responder: ¬øQu√© problema vamos a resolver?</li>
                <li>Dise√±o üìê: En esta etapa, los arquitectos y desarrolladores dise√±an la arquitectura del sistema. Se definen los componentes de hardware y software, la estructura de la base de datos, las interfaces de usuario (UI/UX) y la l√≥gica del sistema. Se responde a la pregunta: ¬øC√≥mo lo vamos a construir?</li>
                <li>Desarrollo o Codificaci√≥n üíª: Es la fase donde los programadores escriben el c√≥digo fuente, traduciendo las especificaciones del dise√±o en un software funcional. Es la etapa m√°s larga del ciclo de vida.</li>
                <li>Pruebas (Testing) üß™: El equipo de calidad (QA) verifica el software en busca de defectos y errores. Se realizan diferentes niveles de pruebas (unitarias, de integraci√≥n, de sistema) para asegurar que el producto cumple con los requisitos y funciona correctamente.</li>
                <li>Despliegue o Implementaci√≥n üöÄ: Una vez que el software ha sido probado y aprobado, se lanza al mercado o se instala en el entorno del cliente (producci√≥n).</li>
                <li>Mantenimiento üõ†Ô∏è: Despu√©s del lanzamiento, el trabajo contin√∫a. En esta fase se corrigen errores que aparecen durante el uso, se realizan actualizaciones y se a√±aden nuevas funcionalidades para mantener el software relevante y funcionando de manera √≥ptima.</li>
                </ol>
                <img src="img/img1.png" alt="Foto de SDLC">
                <p>Cada una de estas etapas es crucial. Omitir o realizar mal una de ellas (especialmente las primeras) inevitablemente genera problemas, retrasos y costos mucho mayores en las fases posteriores.</p>
                </div>

                    <div class="card slide">
                    <h3>Modelos Tradicionales</h3>
                    <p>Estos modelos, tambi√©n llamados "predictivos", se caracterizan por requerir una planificaci√≥n detallada desde el inicio y seguir una secuencia de fases m√°s r√≠gida. </p>
                        <h4>Modelo en Cascada (Waterfall Model)</h4>
                        <p>Es el modelo m√°s antiguo y estricto. Cada fase del SDLC debe completarse por completo antes de pasar a la siguiente, como una cascada que fluye en una sola direcci√≥n. No hay vuelta atr√°s.</p>
                        <ul>
                            <li>Descripci√≥n:</li>
                            <ol>
                                <li>An√°lisis de Requisitos</li>
                                <li>Dise√±o del Sistema</li>
                                <li>Implementaci√≥n (Codificaci√≥n)</li>
                                <li>Pruebas</li>
                                <li>Despliegue</li>
                                <li>Mantenimiento</li>
                            </ol>
                            <li>Ventajas:</li>
                            <ul>
                                <li>Simple y f√°cil de entender: Su estructura es l√≥gica y secuencial.</li>
                                <li>Buena documentaci√≥n: Cada fase genera documentos detallados.</li>
                                <li>Gesti√≥n sencilla: Los hitos son claros y f√°ciles de medir.</li>
                            </ul>
                            <li>Desventajas:</li>
                            <ul>
                                <li>Muy r√≠gido: No permite cambios f√°cilmente. Si se descubre un error en una fase temprana, es muy costoso volver atr√°s.</li>
                                <li>Entrega tard√≠a: El cliente no ve el producto hasta el final del ciclo.</li>
                                <li>Alto riesgo: No es adecuado para proyectos complejos o donde los requisitos no est√°n claros desde el principio.</li>
                            </ul>
                            <li>¬øCu√°ndo usarlo? En proyectos peque√±os, bien definidos, y donde los requisitos son estables y se conocen completamente desde el inicio.</li>
                        </ul>
                        <img src="img/modelocascada.png" alt="Modelo cascada">

                        <h4>Modelo en V (V-Model)</h4>
                        <p>Es una evoluci√≥n del modelo en cascada. La diferencia clave es que enfatiza la relaci√≥n entre cada fase de desarrollo y su correspondiente fase de prueba. Por cada etapa de desarrollo, hay una etapa de prueba paralela.</p>
                <ul>
                    <li>Descripci√≥n: El lado izquierdo de la "V" representa las fases de desarrollo (verificaci√≥n), mientras que el lado derecho representa las fases de prueba (validaci√≥n).</li>
                    <ul>
                        <li>An√°lisis de Requisitos <--> Pruebas de Aceptaci√≥n</li>
                        <li>Dise√±o de Alto Nivel <--> Pruebas de Sistema</li>
                        <li>Dise√±o Detallado <--> Pruebas de Integraci√≥n</li>
                        <li>Codificaci√≥n (en el v√©rtice de la V) <--> Pruebas Unitarias</li>
                    </ul>
                    <li>Ventajas:</li>
                    <ul>
                        <li>Planificaci√≥n temprana de pruebas: Las pruebas se dise√±an desde el principio, lo que mejora la calidad.</li>
                        <li>Mayor probabilidad de √©xito: Al detectar errores en etapas tempranas, se reducen los riesgos.</li>
                        <li>Similar al modelo en cascada en su simplicidad.</li>
                    </ul>
                    <li>Desventajas:</li>
                    <ul>
                        <li>Sigue siendo r√≠gido: No maneja bien los cambios en los requisitos durante el ciclo.</li>
                        <li>El software se prueba al final: Al igual que en la cascada, el producto funcional no est√° disponible hasta el final.</li>
                    </ul>
                    <li>¬øCu√°ndo usarlo? En proyectos donde la fiabilidad y la precisi√≥n son cr√≠ticas (ej. software m√©dico, de aviaci√≥n) y los requisitos son muy claros.</li>
                </ul>
                <img src="img/modelo en v.png" alt="Modelo v">
                <h4>Modelo Iterativo e Incremental</h4>
                <p>Estos dos modelos a menudo se combinan. La idea es desarrollar el software en ciclos repetidos (iteraciones) y en peque√±as porciones (incrementos).</p>
                <ul>
                    <li>Iterativo: Se desarrolla una versi√≥n del software, se obtiene feedback de los usuarios y luego se refina en ciclos sucesivos o iteraciones.</li>
                    <li>Incremental: El software se construye pieza por pieza. En cada incremento, se a√±ade una nueva funcionalidad al producto existente.</li>
                    <li>Descripci√≥n:</li>
                    <ol>
                        <li>Se planifica y desarrolla un peque√±o "incremento" funcional del software.</li>
                        <li>Este incremento pasa por todas las fases (dise√±o, c√≥digo, pruebas).</li>
                        <li>Se entrega una versi√≥n funcional, aunque incompleta, del producto.</li>
                        <li>Se recoge feedback y se inicia el ciclo para el siguiente incremento, mejorando lo existente y a√±adiendo nuevas funcionalidades.</li>
                        <li>Se repite hasta que el producto est√° completo</li>
                    </ol>
                    <li>Ventajas:</li>
                    <ul>
                        <li>Flexibilidad: Permite incorporar cambios y feedback durante el desarrollo.</li>
                        <li>Entregas tempranas: El cliente puede ver y usar partes funcionales del software mucho antes.</li>
                        <li>Riesgo reducido: Los problemas se detectan en incrementos peque√±os, lo que facilita su correcci√≥n.</li>
                    </ul>
                    <li>Desventajas:</li>
                    <ul>
                        <li>Requiere una buena planificaci√≥n: Es necesario tener una idea clara de la arquitectura general desde el principio.</li>
                        <li>Costo total puede ser mayor: La gesti√≥n de m√∫ltiples ciclos puede ser m√°s compleja.</li>
                    </ul>
                    <li>¬øCu√°ndo usarlo? Es ideal para proyectos grandes y complejos, donde los requisitos no est√°n completamente definidos al inicio y se espera que cambien. Es la base de las metodolog√≠as √°giles modernas.</li>
                </ul>
                <img src="img/planificacion inicial.png" alt="Modelo iterativo">
                    </div>
 <!--FIN TERCERA PANTALLA-->
   
    </main>
</body>
</html>